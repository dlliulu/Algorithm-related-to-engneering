
/********************************************************************************************************************************************************************
                                                                  //////////////////////滑动平均滤波//////////////////////////

1.方法：对于算数平均滤波和去极值平均滤波这两种算法有一个共同点：即每个采样周期取得的一个有效采样值是由连续若干个子采样周期取得一批采样值计算出来的，为此，这些算法的的主采样周期都比较长。当被检测物理量变化较快时，较长的主采样周期不能及时采集到被检测物理量中的高频信息，致使系统反应迟钝，实时性难以保证。要保证系统的实时性，必然要按技术指标的要求相应缩短主采样周期，而子采样周期不能随意缩短(受干扰持续时间的制约)，只好减少连续采样次数，连续采样次数的减少有直接降低了滤波效果，既然如此，干脆按技术指标的要求确定一个合理的采样周期，每个采样周期只进行一次采样操作(即采样输出比为1:1)，然后将当前的采样值和之前连续的若干次采样值(最近历史采样值)一起进行平均，将得到的平均值作为当前有效采样值投入使用。由于参与平均运算的历史采样值个数固定且内容不断更新，相当于一个滑动的时间窗口，故将这种平均滤波方式成为"滑动平均滤波"，窗口的大小用采样数据样本个数m来表示。按这种方式进行采样就不再存在主采样周期和子采样周期的问题。
		
2.例程：
		(1)调用函数
		(2)变量说明：
		(3)常量说明：
		(4)入口：
		(5)出口：
********************************************************************************************************************************************************************/


typedef unsigned char INT8U;
typedef unsigned int INT16U;

#define M 6            //滑动窗口大小
INT16U history[M];     //采样值的历史队列(循环队列)
INT8U p;
INT16U Samp;           //滤波算法输出的有效采样值

void TaskSampCtrl(void * pdata)
{
	INT8U i;
	INT16U S;
	
	//准备工作，进行M-1次采样，这样一来才可以保证第一次输出的有效采样值是正确，如果一开始这个数组只有一个有效采样值，其他值为0，则平均以后的数值肯定不正确
	for (p=0; p<M-1; P++)
	{
		history[p] = SampleAdc();
		OSTimeDly(5);            //采样周为20*5ms = 100ms = 0.1s;(系统节拍周期为20ms)
	}
	//该循环结束之后，p = M-1
	
	while (1)
	{
		//每次进来更新一次数据
		history[p] = SampleAdc();
		P++;  //第一次进来之后，p = M
		if (p == M)
		{
			P = 0;      //保证窗口大小一致
		}
		S = 0;
		for (i=0; i<M; i++)
		{
			S += history[i];  //对M个理事采样数据以及当前采样数据构成的窗口数据进行求和
		}
		Samp = S/M;    //求平均值，作为有效采样值
		TempCtrl();    //调用温度控制算法
		OSTimeDly(5);	
	}	
}


/********************************************************************************************************************************************************************
                                                        //////////////////////加权平均滤波//////////////////////////
														
1.方法：在滑动平均滤波算法中，窗口中的m个采样数据样本以平等身份参与运算，这对抑制随机干扰比较有利，但将有超时严重的滞后效果，降低系统反应速度。为了提高系统的反应速度，滤波算法的输出应该及时反映当前采样值中包含的有效信息，即增加即时数据样本和近期数据样本的权重，降低早期数据样本的权重。为此，为滑动窗口的各个数据样本分配不同的"加权系数"，进行加权平均运算。这种滤波算法称为"滑动加权滤波"
		
2.例程：
		(1)调用函数
		(2)变量说明：
		(3)常量说明：
		(4)入口：
		(5)出口：
********************************************************************************************************************************************************************/

typedef unsigned char INT8U;
typedef unsigned int INT16U;

#define M 6
#define Q 21     //1+2+3+4+5+6=21
INT16U history[M];
//对应的权重分别为：1/21， 2/21， 3/21，  4/21，  5/21，  6/21
INT8U k[M] = {1, 2, 3, 4, 5, 6};

INT8U p;
INT16U Samp;

void TaskSampCtrl(void * pdata)
{
	INT8U i, j;
	float S;
	//准备工作，进行M-1次采样，这样一来才可以保证第一次输出的有效采样值是正确，如果一开始这个数组只有一个有效采样值，其他值为0，则平均以后的数值肯定不正确
	for (p=0; p<M-1; P++)
	{
		history[p] = SampleAdc();
		OSTimeDly(5);
	}
	//该循环结束之后，p = M-1
	
	while (1)
	{
		//每次进来更新一次数据
		history[p] = SampleAdc();
		P++;  //第一次进来之后，p = M
		if (p == M)
		{
			P = 0;
		}
		S = 0;
		j = p;
		/**********************************************************************************************************************************
		假设此时：p =2; history[1]为当前采样值，其所占比重应该是最重，而history[2]所占比重应该是最小的则j =2;此时进入下面的for循环
		(1)第一次for循环：	1 0 5 4 3 2
		   数组：   history[1] history[0] history[5] history[4] history[3] history[2]
	       对应权重：    6/21    5/21        4/21       3/21       2/21       1/21
		   
		i=0; S = 0 + 1*history[2]; j = 3; j<6; i=1;
		i=1; S = 0 + 1*history[0] + 2*history[3]; 
		***********************************************************************************************************************************/
		//所以下面的for循环是为了保证当前的采样值所占权重最大，近期的权重一次减少
		for (i=0; i<M; i++)
		{
			S += k[i]*history[j];
			j++;
			if (j==M)
			{
				j =0;
			}
		}
		Samp = S/Q;
		TempCtrl();
		OSTimeDly(5);	
	}	
}





