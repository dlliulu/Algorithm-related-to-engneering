
/********************************************************************************************************************************************************************
                                                        
														///////////////////一阶滞后滤波算法///////////////////
														
1.方法：将一阶滞后滤波器，在硬件上，由于电容电流Ic = dq/dt = d(CVc)/dt = C(dVc/dt),于是对于一般的一阶RC滤波电路根据基尔霍夫电压定律可写出：RC(dVc/dt) + Vc = Vi;其中，RC(dVc/dt)：电阻两端电压，Vc:电容两端电压；Vi：输入端电源电压，最终可获得其对应的一阶微分方程：Vc(t) = Vi(1-e^(-t/RC));

	(1)经推导可获得一阶滞后滤波算法：Yn = αXn + (1-α)Yn_1;
	其中：Yn:本次滤波的输出值；
	      Xn:本次采样值
		  Yn_1:上次滤波的输出值
		  α：滤波系数，其值通常远远小于1
	综合，由以上可以看出，本次滤波的输出值主要取决与上次的滤波输出值，本次采样值对本次滤波输出的贡献是比较小的，但多少有些修正作用。这种算法变模拟了具有较大惯性的一阶滞后滤波器的功能。
	
	(2)一阶滞后滤波算法的截止频率可由下式计算出来：
	                              fL = α/(2πt)
其中，α：为滤波系数；t：为采样间隔时间，单位为s
	例如，当t = 0.5s(即采样2次/s)，α = 1/32；时，有：
	                              fL = α/(2πt) = (1/32) / (2*3.1416*0.5) = 0.01Hz
	可见，只有当参数为变化很缓慢的物理量时(如大型贮水池的水位信号)，采用一阶滞后滤波算法是
很有效的。
	另一方面，它不能滤除高于二分之一采样频率的干扰信号。本例中采样频率为2Hz，故对1Hz以上的
干扰信号通常配合硬件滤波电路来滤除。
	其实一阶滞后滤波算法流程与加权平均滤波相似，而加权系数只有2个：α和(1-α)
		
2.例程：
		(1)调用函数
		(2)变量说明：
		(3)常量说明：
		(4)入口：
		(5)出口：
********************************************************************************************************************************************************************/

#define A 0.03125  //滤波系数
float Samp;        //滤波算法输出的有效采样值

void TaskSampleCtrl(void * pdata)
{
	float new;
	
	Samp = SampleAdc();                     //初始化，获得第一次采样值
	OSTimeDly(25);
	while (1)
	{
		new = SampleAdc();                  //新的采样数据
		Samp = A*new + (1-A)*Samp;          //一阶滞后滤波算法
		TempCtrl();                         //调用温度控制算法
		OSTimeDly(25);                      //采样周期为0.5s(系统节拍周期为20ms)
	}	
}



