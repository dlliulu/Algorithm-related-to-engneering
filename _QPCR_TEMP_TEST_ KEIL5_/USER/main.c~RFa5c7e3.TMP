/**
  ******************************************************************************
  * @file    Project/STM32F2xx_StdPeriph_Template/main.c 
  * @author  MCD Application Team
  * @version V1.1.0
  * @date    13-April-2012
  * @brief   Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */ 

/* Includes ------------------------------------------------------------------*/
#include "main.h"

#define LED_TURN()    (GPIOA->ODR ^= GPIO_Pin_8)   //状态显示，一是否死机，二是某种状态显示

//
#define  Main_Display        0
#define  Data_Display        1
#define  Line_Display        2
#define  Set_Display         3

#define  Res_Mode            1
#define  Temp_Mode           2


//温度值不精确
const float R[200] = {
                    36668.6695,35231,33677.764,32367.993,31040.4175,29803,28600,27460.8135,26305.4685,25276.9285,
                    24309.5275,23431,22443.0375,21540,20793,19891.916,19180,18456,17834.4495,17067.5095,16420.207,
                    15832.1705,15324.293,14692,14100.2015,13608.645,13046.464,12583,12107.732,11691,11228.214,10831.3755,
                    10452.286,10088,9684.465,9350.3665,9033,8690.1075,8383.297,8096.6115,7806.0115,7539,7275.092,7030.638,
                    6819.979,6536.05,6339.7255,6120.5185,5912.3405,5689.553,5508.831,5336.3785,5140.9915,4988.221,
                    4810.0355,4657,4507.637,4353.9845,4215.879,4088.7985,3950,3806.634,3690.9675,3578.333,3473,3349.591,
                    3248,3145,3054.14,2960,2868.952,2771.448,2688.2845,2583.39,2505.27,2431.25,2356.57,2281.34,2212.87,
                    2144.93,2081.87,2019.76,1959.5,1900.86,1844.17,1791.42,1736.09,1686.48,1638.69,1590.21,1545.14,
                    1501.76,1457.4,1416.15,1376.25,1336.8,1298.97,1263.07,1227.97,1192.61,1160,1127.41,1095.86,1065.68,
                    1037.06,1008.5,982.9,955.28,929.36,904.37,880.68,857.31,834.36,813.14,791.64,770.72,750.47,731.15};


//温度值更精确
//32℃开始到145℃，间隔0.1℃；
const float RT[2000] = {
    36668.6695,36525.3815,36367,36209.421,36077.6565,35885.632,35747.968,35594.202,
    35433.3275,35332,35231,34984.2235,34832.115,34705.9735,34596.5355,34406.6065,
    34280.189,34170.808,34002.3795,33836.819,33677.764,33550.684,33440.475,33308,
    33163,33056.0965,32923.2835,32735.7805,32582.0175,32475.776,32367.993,32180.269,
    32054.6235,31929.199,31786.0215,31682.153,31530.0445,31407.8715,31265.962,31154.8715,
    31040.4175,30871.8795,30763.215,30643.0825,30504.1505,30410.9775,30258.7025,
    30127.2685,29994.621,29906.6305,29803,29689,29606.162,29437.459,29301.115,
    29161.907,29096.355,28940.9935,28829.793,28696.76,28600,28504.846,28479.5405,
    28368.891,28215,28080,27946,27790,27658.02,27568.486,27460.8135,27330,27204.8335,
    27091.5925,27011.486,26884,26757.2735,26659.8005,26588.8455,26444,26305.4685,
    26243.5,26126.2345,26037.2515,25963.761,25801.398,25722.3385,25608.8225,25519.7295,
    25399.597,25276.9285,25187.56,25119.745,25012.4035,24903.2425,24814.5905,24690.8745,
    24566.4975,24496.921,24411.356,24309.5275,24223.963,24176.825,24053.991,24008.893,
    23941.467,23868.472,23789,23709.0305,23564,23431,23287.3275,23229.6045,23046.621,
    22982.172,22900.3565,22801.8355,22685.9485,22602,22526,22443.0375,22357.473,22269,
    22188,22100.0075,22074.426,21940,21806.4275,21674.332,21608,21540,21470,21412.07,
    21311.3435,21241.547,21174.5065,21072,20971.0695,20888.3165,20829.601,20793,20757.9845,
    20731.852,20657.9755,20509,20373,20225.301,20188.6385,20111.619,19981.839,19891.916,
    19862.0345,19811.148,19669.459,19626.015,19576.231,19497.723,19413,19340,19266,19180,
    19108.658,19028,18952.9105,18896.897,18836.0315,18741.6455,18666.6115,18593.4515,18519.85,
    18456,18393,18330.5825,18280,18232.834,18108.346,18060.437,17942.6205,17898.9005,17856.78,
    17834.4495,17735,17639.0615,17544.9515,17466.4435,17417.321,17342.7275,17266.37,17200.4325,
    17148.057,17067.5095,17039.723,16937.233,16857.5675,16807.894,16761.6385,16741.2395,
    16647.295,16576.1745,16509.3,16420.207,16350,16295,16228,16166.049,16120,16073,16026,
    15980.5855,15880.5215,15832.1705,15760.222,15617.5395,15608.222,15574,15541.2925,15447.017,
    15396.9025,15332.3975,15328,15324.293,15207,15090.81,15022.2815,14965.1645,14907.0005,
    14854.846,14816.2535,14764.154,14726.113,14692,14659.569,14594,14533,14468.2065,14410,
    14340,14278,14215.9235,14144.9685,14100.2015,14026.27,13986.0235,13927.639,13875.539,
    13833.584,13823.6605,13788,13753.753,13701.929,13608.645,13545,13480,13416,13354.9815,
    13298.251,13243.6155,13217.2625,13157.0585,13105.51,13046.464,13003.5165,12968.9485,
    12935.4835,12900.916,12833.545,12760.8815,12718.3745,12670.41,12626.525,12583,12507,
    12460,12425,12396,12367,12308.0265,12252.5085,12193.187,12149.0815,12107.732,12070.5735,
    12018.253,11962.7905,11928.609,11888.5285,11838.3585,11773.6335,11768.2855,11726.551,
    11691,11655.927,11611.05,11558.564,11524,11491.1935,11402.7065,11365.217,11319.4025,
    11269.5635,11228.214,11212.8325,11184,11157.039,11132,11107.9165,11029,10951.287,
    10903.764,10881.325,10831.3755,10781.4815,10743.22,10705.0135,10703.4695,10651.4255,
    10590.725,10564.703,10511.721,10484.924,10452.286,10398.0915,10348.914,10324.4905,
    10289.9225,10244.5495,10209.8715,10189.197,10184.6765,10136,10088,10040,9993.534,
    9940.4975,9912.9865,9884.4285,9843.135,9795.225,9777.307,9737.502,9684.465,9663.074,
    9617.8105,9590.19,9564.5535,9528.222,9479.981,9455.944,9434.222,9391.8255,9350.3665,
    9310.451,9276.8205,9242.363,9211.324,9182.6005,9155.696,9125.043,9091.0815,9060,9033,
    9003.091,8948.6205,8916.258,8887.149,8855.7235,8822.424,8800.4265,8772.5295,8723.573,
    8690.1075,8660.612,8657.4145,8614,8550,8516,8489,8462.6885,8451.993,8411.251,8383.297,
    8349.2255,8321.825,8298.78,8282.516,8237.859,8199.212,8172.473,8153.3425,8118.664,
    8096.6115,8063.0915,8033.155,8007.022,7969.5325,7945.7705,7922.285,7895.4355,7864.3965,
    7839.7525,7806.0115,7776.847,7757.606,7740.4045,7728.5515,7691,7654,7615,7579.089,
    7572.363,7539,7509,7476.82,7448,7418.6005,7401.5645,7380.394,7346.102,7319.5835,
    7294.002,7275.092,7253.4805,7227.9545,7207.0045,7178.281,7152.81,7112.5085,7092.1095,
    7068.899,7038.577,7030.638,7009.1365,6971.7565,6943.2535,6921.9175,6901.4085,
    6882.1125,6853.058,6842,6831.3365,6819.979,6790,6759,6730,6700,6669,6642.124,
    6610.9745,6589.693,6574.367,6536.05,6517.085,6502.971,6488.306,6483.73,6464.93,
    6437.0885,6409,6384,6356.9265,6339.7255,6298.487,6273.0135,6250.354,6225.8755,
    6205.6425,6195.002,6180.171,6173.39,6147.588,6120.5185,6092,6063.016,6058.054,
    6052.872,6023.707,5980.594,5956.06,5937.8665,5924.525,5912.3405,5898,5886,5861,
    5834.0535,5805,5775,5745.567,5732.7765,5709,5689.553,5672,5656.309,5643.573,5634.311,
    5600.2395,5584.031,5562.1435,5544,5525.095,5508.831,5486.117,5469.963,5452.486,
    5447.304,5425,5404,5382,5361.243,5354.186,5336.3785,5314,5292.108,5276.947,5255,
    5237,5218,5200,5178,5160.949,5140.9915,5117.2845,5098.3195,5091.2625,5076.5975,
    5055.041,5038.9425,5027.1445,5010.991,5000,4988.221,4980.0065,4952.3855,4933.475,
    4928.2375,4902,4878,4852.983,4850.392,4826.1885,4810.0355,4797.41,4777.2315,
    4768.962,4747.681,4730,4713.9955,4711.79,4700,4688.635,4657,4639,4621,4603.07,
    4587.1375,4580.742,4562.6585,4553.6725,4545.0715,4519.4355,4507.637,4494.571,
    4479.7405,4467,4455,4443,4431,4406,4380.062,4364.4045,4353.9845,4340.2565,
    4321.016,4310.4855,4301.775,4284.3535,4274.4295,4250.5575,4236.8295,4222.4955,
    4215.879,4202.207,4187.4295,4175.8515,4162.289,4142.993,4128.769,4116.8055,
    4101.148,4089.846,4088.7985,4075,4062.666,4037.6915,4027.8775,4013.158,4002,3992,
    3982.1185,3965,3950,3936,3920,3904,3890.4345,3874.446,3865.956,3856.087,
    3843.2965,3825.599,3806.634,3804.0425,3788.33,3781.3285,3768.428,3761.977,
    3749.076,3733,3718,3703.593,3690.9675,3684.241,3673.3805,3664.449,3647.5235,
    3634.788,3620.2885,3609.7585,3599.4485,3585.886,3578.333,3568.8505,3561.7935,
    3545.199,3533.07,3524.0835,3511.9545,3506.717,3498.447,3486,3473,3461,3449,3436,
    3425.342,3420.9315,3404.2265,3390.168,3376.4405,3363.5395,3349.591,3343.4715,
    3337.6825,3318.6625,3311.3845,3307.4155,3294.2385,3285.528,3273.454,3259.065,
    3248,3239,3229.2935,3218.7085,3209.887,3205.3665,3190.205,3180.888,3166.884,
    3156.685,3145,3134,3123.3305,3119.1405,3111.3115,3103.042,3093.0625,3078.563,
    3068.474,3062.7955,3054.14,3047.8545,3047.469,3016.595,3012.1845,3000.5515,
    2990.793,2987.706,2984.6185,2970.339,2960,2950.6025,2940.7335,2935.11,2926.234,
    2914.601,2902.086,2886.98,2876.5865,2873.638,2868.952,2866.3605,2844.1975,2836.81,
    2834.1635,2827.658,2811.725,2804.7785,2793.2005,2774.401,2771.448,2767.344,
    2763.65,2746.394,2744.3535,2736.5255,2729.744,2720.0955,2696,2692,2688.2845,
    2687.0165,2682.11,2679.7945,2661.105,2656.6945,2645.7235,2608.88,2604.03,2594.26,
    2583.39,2576.52,2570.3,2561.97,2555.1,2545.81,2536.09,2528.86,2525.34,2513.45,
    2505.27,2497.14,2489.36,2482.26,2474.18,2469.57,2460.74,2452.23,2445.09,2437.12,
    2431.25,2420.67,2415.06,2405.47,2397.75,2391.54,2383.36,2376.8,2373.22,2361.16,
    2356.57,2344.64,2340.3,2331.85,2323.95,2318.29,2310.43,2304.01,2298.99,2290.29,
    2281.34,2274.86,2268.97,2260.88,2256.11,2248.62,2239.53,2233.94,2226.06,2221.09,
    2212.87,2206.52,2199.07,2194.58,2186.93,2179.92,2177.69,2166.14,2159.67,2152.13,
    2144.93,2139.31,2133.94,2127.12,2122.48,2114.33,2108.15,2101.32,2095.55,2087.97,
    2081.87,2076.46,2068.96,2066.22,2057.39,2053.07,2044.08,2040.67,2031.03,2024.96,
    2019.76,2012.73,2006.8,2002.79,1995.14,1990.04,1982.35,1977.4,1971.1,1966.32,1959.5,
    1953.78,1947.4,1941.63,1938.16,1929.48,1924.85,1918.71,1912.45,1907.52,1900.86,
    1894.93,1890.87,1884.07,1879.79,1873.3,1867.09,1860.25,1855.76,1851.68,1844.17,
    1839.18,1834.18,1828.13,1824.03,1817.84,1812.45,1805.22,1802.13,1796.14,1791.42,
    1786.27,1779.2,1773.94,1768.72,1763.74,1758.44,1751.88,1748.54,1743.67,1736.09,
    1732.75,1728.31,1722.65,1718.15,1711.29,1706.69,1703.62,1699.04,1690.62,1686.48,
    1681.58,1675.3,1671.2,1667.22,1662.67,1657.25,1654.52,1646.94,1642.72,1638.69,
    1633.29,1628.75,1623.51,1619.67,1614.12,1608.87,1604.78,1602.06,1596.17,1590.21,
    1585.81,1581.14,1577.5,1572.16,1567.17,1562.36,1558.22,1554.67,1550.5,1545.14,
    1539.96,1536,1530.82,1526.3,1522.79,1518.22,1513.53,1509.03,1505.05,1501.76,
    1496.54,1491.75,1487.27,1481.88,1477.7,1473.92,1470.41,1465.18,1461.21,1457.4,
    1454.69,1449.4,1444.12,1441.14,1437.37,1433.11,1427.86,1424.94,1419.64,1416.15,
    1410.68,1406.82,1406.01,1400.12,1394.9,1392.29,1387.49,1383.6,1379.13,1376.25,
    1374.24,1368.9,1363.62,1361.65,1355.26,1354.83,1348.28,1343.64,1340.02,1336.8,
    1334.08,1330.45,1325.14,1321.63,1317.7,1313.4,1309.88,1306.76,1303.06,1298.97,
    1295.97,1291.03,1287.91,1284.48,1280.05,1276.96,1272.59,1269.35,1265.27,1263.07,
    1260.52,1254.6,1253.09,1247.5,1244.9,1241.34,1238.12,1234.68,1231.37,1227.97,
    1224.2,1220.62,1215.6,1212.58,1210.72,1206.47,1202.36,1199.42,1195.95,1192.61,
    1189.29,1184.62,1182.22,1178.6,1175.53,1172.15,1169.39,1165.68,1162.02,1160,1156,
    1152.32,1151.1,1145.75,1142.56,1139.57,1135.85,1133.18,1131.07,1127.41,1124.93,
    1120.84,1117.57,1114.61,1111.16,1108.09,1104.7,1103.66,1099.44,1095.86,1093.43,
    1090.51,1087.32,1083.77,1080.75,1077.9,1074.88,1071.46,1069.61,1065.68,1063.53,
    1061.12,1056.8,1054.32,1051.15,1048.29,1046.51,1041.92,1039.5,1037.06,1034.5,
    1030.81,1028.73,1025.65,1023.41,1020.15,1016.01,1014.27,1012.04,1008.5,1006.03,
    1004,1000.12,997.64,994.34,992.23,989.85,986.71,984.21,982.9,978.65,975.43,972.79,
    970.44,967.52,966.47,963.47,959.99,958.35,955.28,952.53,950.46,946.86,944.73,942.05,
    939.59,936.49,936.18,932.3,929.36,927.05,924.34,922.12,920.81,916.67,914.17,912.37,
    909.55,907.06,904.37,901.43,899.88,897.58,894.52,892.12,890.09,887.29,885.85,883.83,
    880.68,878.85,875.11,874,870.77,869.89,866.51,864.13,861.51,860.44,857.31,854.97,
    852.59,852.38,847.76,845.9,843.78,841.59,839.1,838,834.36,832.28,830.4,827.91,
    825.16,824.25,821.47,819.29,817.85,814.75,813.14,809.94,807.5,806.39,803.61,
    802.16,799.99,797.66,795.41,793.58,791.64,789.08,787.51,785.24,783.02,781.5,
    779.42,777.32,775.94,772.72,770.72,768.45,767.88,765.47,762.73,761.12,758.87,
    756.58,754.64,752.63,750.47,749.22,746.64,744.74,742.74,740.6,738.74,736.89,
    735.13,733.26,731.15,729.32,727.34,724.84,722.77,719.1};

//石冢传感器0-32℃的真值表，以1℃为间隔
const float RT_32[100] = {
	161900.00, 153900.00, 146300.00, 139200.00, 132500.00, 126100.00, 120100.00,	
	114400.00, 109000.00, 103900.00, 99130.00, 94500.00, 90120.00, 85980.00,	
	82050.00, 78320.00, 74790.00, 71440.00, 68260.00, 65250.00, 62380.00,	
	59650.00, 57050.00, 54580.00, 52230.00, 50000.00, 47850.00, 45800.00,	
	43850.00, 42000.00, 40240.00, 38550.00, 36950.00};


//********************************************************************************//
float Temp[20] = {0,0,0,0,0,0,0,0,0};

//该表格做查表用
const float Temp_Compare[20] = {105.00, 95.00, 90.00, 70.00, 60.00, 50.00, 30.00};

//NTOE:为了方便数据在E2PROM中存储，故将个校准点数据扩到了1000倍，保证了0.001℃的精度
//该表格记录校准设备在校准点的数据
const u32 Temp_Correct[20] = {105000, 95000, 90000, 70000, 60000, 50000, 30000};

//NTOE:为了方便数据在E2PROM中存储，故将个校准点数据扩到了1000倍，保证了0.001℃的精度
//该表格记录工装在个校准点的数据
const u32 Temp_Gongzhc[20] = {105000, 95000, 90000, 70000, 60000, 50000, 30000};

char arr[10];
char* lptr = arr;


u8 Tim3_Flag = 0;			  //定时到了处理
u8 NEW_ORDER_FLAG = 0;
u8 Usart2_FLAG = 0;
u8 USART_Tx[BUF_SIZE];
u8 USART_Tx2[3000] = {0XA5,0X5A,0X0A,0X82,0X00,0X00,0X30,0X31,0X32,0X33,0X34,0X35 };//{0};
u8 RxBuffer_3[50] = {0};
u8 RxBuffer_2[50] = {0};
u8 RxCounter_3 = 0;
u8 RxCounter_2 = 0;
u8 Col_Times = 50; //25HZ
u8 Data_Out_Flag = 0;
u8 Mid_Filt_Win = 9;
u8 Out_Flag = 0;
u8 X_Axle = 1;
u8 USART2_BUSY = 0;
u8 LCD_Display_Flag = 0;
u8 LCD_Interface = 0;   //全局变量用来表示不同的的界面切换,取值主要是做如下取值
/*******************************************************
	#define  Main_Display        0
	#define  Data_Display        1
	#define  Line_Display        2
	#define  Set_Display         3
********************************************************/
u8 Display_Channel[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0};//{1,2,3,4,5,6,7,8};
u8 Display_Line[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0};//{1,2,3,4,5,6,7,8};
u8 Set_ChX = 0;
u8 Calib_Mode = 2;
u16 Line_Flag = 0x0000;
u16 Y_Axle = 8500;

//上拉电阻的阻值
//u16 RES[30] = {5000 ,5000 ,5000 ,5000 ,5000 ,5000 ,5000 ,5000 ,5000 ,5000 ,5000 ,5000 ,5000 ,5000 ,5000, 5000 };
u16 RES[30] = {5004, 5002, 5003, 5003, 5002, 5002, 5002, 5003, 4998, 4995, 4997, 4997, 4997, 4997, 4997, 4998};

u16 ADCValue;
u16 i = 0;
u16 j = 0;
u16 k = 0;

u16 ADC_Value[200] = {0};

u16 Mid_data_buf[30][30] = {0};		 //中值滤波，滤除毛刺，平缓波形

u16 Mid_count[30]  = {0};

u16 RxTim3 = 0;

u16 RxTim2 = 0;

u16 Length_Order = 0;

u16 Col_DATA = 0;

u16 Cal_Mode = 0;

u16 Rate_Out = 10;

u16 Line_Data = 0;

u16 Col_Channel = 0xFF;
float Col_Temp;
/*
K1	1.00018		K2	0.9996
B1	-5.87317		B2	12.75542
*/
float Corr_B1 = -5.87317;
float Corr_K1 = 1.00018;

float Corr_B2 = 12.75542;
float Corr_K2 = 0.9996;

typedef union UNI_DATA
{
  u16 u16_D[30];
  u8 u8_D[60];
}ORIGIN_DATA;
ORIGIN_DATA REF_R;

typedef union UNI_DATA_T
{
  u32 u32_D[30];
  uint8_t u8_D[120];
}TEMP_DATA;
TEMP_DATA COR_T, GOZ_T;

//*************************//
#define sEE_WRITE_ADDRESS1        0x00
#define sEE_READ_ADDRESS1         0x00
#define BUFFER_SIZE1             (countof(Tx1_Buffer)-1)
#define BUFFER_SIZE2             (countof(Tx2_Buffer)-1)
#define sEE_WRITE_ADDRESS2       (sEE_WRITE_ADDRESS1 + BUFFER_SIZE1)
#define sEE_READ_ADDRESS2        (sEE_READ_ADDRESS1 + BUFFER_SIZE1)

/* Private macro -------------------------------------------------------------*/
//当然实际应用中一般用来计算数组元素的大小
//举例：int a[10]; 则sizeof(a) = 4*10 = 40； sizeof(*(a)) = sizeof(a[0]) = 4；则sizeof(a) / sizeof(*(a)) = 40/4 = 10
//举例：char a[10]; 则sizeof(a) = 1*10 = 40； sizeof(*(a)) = sizeof(a[0]) = 1；则sizeof(a) / sizeof(*(a)) = 10/1 = 10
#define countof(a) (sizeof(a) / sizeof(*(a)))

/* Private variables ---------------------------------------------------------*/
typedef enum 
{
  COM1 = 0,
  COM2 = 1
} COM_TypeDef;
 
typedef enum 
{
  FAILED = 0, 
  PASSED = !FAILED
} TestStatus; 
uint8_t Tx1_Buffer[] = "SZW-STM32F40xx I2C buffer 1 transfer";
uint8_t Tx2_Buffer[] = "SZW-STM32F40xx I2C buffer 2 transfer";
uint8_t Rx1_Buffer[BUFFER_SIZE1], Rx2_Buffer[BUFFER_SIZE2];
volatile TestStatus TransferStatus1 = FAILED, TransferStatus2 = FAILED;
volatile uint16_t NumDataRead = 0;
//*************************//
//*************************//
//*************************//


//移植需要修改的部分，第一:串口；   第二:ADC相关
int main(void)
{
  	uint8_t z = 0;
    uint8_t  R[20];
    Sys_GPIO_Init();
    //  Sys_SPI1_Init();
    Sys_NVIC_Init();
    Sys_ADC_Init();
	//    Sys_DAC_Init();    
    USART1_Init();    //USART1主要是和触摸屏进行交互通信
    USART2_Init();    //USART2主要是和PC进行交互通信
    TIM3_Init();
    sEE_Init();  
	R[0] = 0;
	sEE_WriteBuffer(R, 0X00, 1);
	sEE_WaitEepromStandbyState();  
	//系统初始化之后，首先看E2PROM内部是否已经保存了数据
    NumDataRead = 1;
	//从E2PROM中读出的数据存储在数组R[]中
    sEE_ReadBuffer(R, 0x00, (uint16_t *)(&NumDataRead));
    if(R[0] == 1 )   //在E2PROM内部已经保存了数据
    {
				//读取上拉电阻的值
        NumDataRead = 32;
        sEE_ReadBuffer(REF_R.u8_D, 0x02, (uint16_t *)(&NumDataRead));//02+32 地址存储r值

				//读取各温度标定点数据
        NumDataRead = 28;
        sEE_ReadBuffer(COR_T.u8_D, 0x02+32, (uint16_t *)(&NumDataRead));//02+32 地址存储r值 
        
        //读取各温度标定点工装
        NumDataRead = 28;
        sEE_ReadBuffer(GOZ_T.u8_D, 0x02+32+32,(uint16_t*)(&NumDataRead));//02+32 地址存储r值 	
    }
    else             //在E2PROM内部未保存数据
    {
        R[0] = 1;
        sEE_WriteBuffer(R, 0X00, 1);      //24C08的第一字节主要是一个标志位，用来表示E2PROM内部是否已经保存数据
        sEE_WaitEepromStandbyState();  
		    //保存上拉电阻的数据
        for(i = 0; i < 16; ++i)
        {
            REF_R.u16_D[i] = RES[i];      //由于RES[]该数组的每一个元素是u16，所以现在要保存16个数据，则需要16*2Bytes空间
        }
        sEE_WriteBuffer(REF_R.u8_D, 0X02, 32); 
        sEE_WaitEepromStandbyState();  

		//保存计量单位校准点校准数据
		for(i = 0; i < 7; ++i)
        {
            COR_T.u32_D[i] = Temp_Correct[i];      //由于RES[]该数组的每一个元素是u16，所以现在要保存16个数据，则需要16*2Bytes空间
        }
        sEE_WriteBuffer(COR_T.u8_D, 0X02+32, 28); 
        sEE_WaitEepromStandbyState();  

		//保存校准点对应的工装温度数据
		for(i = 0; i < 7; ++i)
        {
            GOZ_T.u32_D[i] = Temp_Gongzhc[i];      //由于RES[]该数组的每一个元素是u16，所以现在要保存16个数据，则需要16*2Bytes空间
        }
        sEE_WriteBuffer(GOZ_T.u8_D, 0X02+32+32, 28); 
        sEE_WaitEepromStandbyState();  
        
    }
    ADS8832_PrepareSpi();  
    ADS8832_Init();    
    TIM_Cmd(TIM3,ENABLE);	   // Enables or disables the specified TIM peripheral
    while (1)
    {
        //和PC进行交互通信USART2
        if(NEW_ORDER_FLAG)      //USART1每次接收完成整个命令之后将NEW_ORDER_FLAG该标志位进行置位
        {
            NEW_ORDER_FLAG = 0;
            New_Order();
        }

		//和触摸屏进行交互通信,USART1
        if(Usart2_FLAG)        //USART1每次接收完成整个命令之后将Usart2_FLAG该标志位进行置位
        {
            Usart2_FLAG = 0;
            New_Comm();
        }
        if(Tim3_Flag)    //20ms进行AD采集一次
        {
            Tim3_Flag = 0;
            ADS8832_16Channel_Sample();   //单次采集      
            GPIOA->ODR ^= GPIO_Pin_8;     //20msLED进行一次反转，用来表示整个产品的运行状态
        }
				//$OA:000000;B:000000;C:000000;D:000000;E:000000;F:000000;G:000000;H:000000;I:000000;J:000000;K:000000;L:000000;M:000000;N:000000;O:000000;P:000000;Z
        else if(Data_Out_Flag)	 //把数据输出到电脑上，每50*20ms=1s在TIM3的中断函数中会将Data_Out_Flag该标志位置位
        {
            j = 0;
            Data_Out_Flag = 0;
            USART_Tx[j++] = '$';      //USART_Tx[0] = '$';
            USART_Tx[j++] = 'O';      //USART_Tx[1] = 'O';
            for(i = 0; i <16; ++i)//16
            {
                ADC_Value[i] = Corr_K_B(i,ADC_Value[i]);
                USART_Tx[j++] = i+65;  //USART_Tx[2] = 'A';  65的ASCII码对应的是:A; A 0; B 1 C2 D3 E4 F5 G6 H7
                USART_Tx[j++] = ':';   //USART_Tx[3] = ':';
                if(Out_Flag == 0)//输出温度值
                {					
					Temp[i+1] = Calculate_Temp_SZ(ADC_Value[i] , REF_R.u16_D[i] , 2.041 );//ADC_Value[i] 
															
					//Calculate_Temp_SZ()计算实际温度函数 
                    //将实际温度转换为ASCII码值表示
                    TreePoint_To_ASCII(Temp[i+1], lptr);  //char* lptr = arr;  lptr是一个全局变量，指针变量，指向arr[]数组
                }
                else  //输出AD值
                {
                    INT_To_ASCII(ADC_Value[i], lptr);
                }      
                //  ADC_Value[i] = 0;
                for(z=0; z<7; z++)           // USART_Tx[4]到USART_Tx[11]表示一个温度值用ASCII码表示的
                {  
                    if(arr[z] == '\0')
                    {
                        break;
                    }
                    else
                    {
                        USART_Tx[j++] = arr[z];
                    }
                }
                USART_Tx[j++] = ';';         //USART_Tx[12],   故16个温度值: 12*16 + 1 = 193个数据，即USART_Tx[]至少有192个数据
            }
            USART_Tx[j++] = 'Z';
            //            USART_Tx[j++] =32;
            //            USART_Tx[j++] = '\n';      
            USART2_Tx(j);  //将数据输出到PC上，将USART_Tx[]该内存区域内的数据通过DMA传递到USART3该串口处
        }
         if(LCD_Display_Flag)   //20*20ms往串口屏发数据,每20*20ms在TIM3的中断函数中会将LCD_Display_Flag该标志位置位
        {
            LCD_Display_Flag = 0;
            Dispaly();         //也就是说每400ms进行一次画面更新
        }
    }
}
void Dispaly(void)
{
    u16 i = 0;
    u8  z = 0;
    u16 k = 0;

	//通过从USART1出口处得到的数据进行解析，进而获得LCD_Interface的具体值，根据不同的LCD_Interface的值进行相应的显示
    switch(LCD_Interface)  
          {
              case   Data_Display:
                                                for( i = 0; i < 16; ++i)
                                                {
                                                    USART_Tx2[k++] = 0xA5;
                                                    USART_Tx2[k++] = 0x5A;
                                                    USART_Tx2[k++] = 0X09;
                                                    USART_Tx2[k++] = 0X82;
                                                    USART_Tx2[k++] = 0X00;
                                                    USART_Tx2[k++] = 0X00 + i*7;
                                                    TreePoint_To_ASCII(Temp[i+1], lptr);
                                                    for(z=0 ; z<6 ;z++)
                                                    {  
                                                        if(arr[z] == '\0')
                                                        {
                                                            break;
                                                        }
                                                        else
                                                        {
                                                            USART_Tx2[k++]= arr[z];
                                                        }
                                                    }
                                                }
              break;
			  
			  
              case   Line_Display:
                                                for( i = 0; i < 16; ++i)
                                                {
                                                    USART_Tx2[k++] = 0xA5;
                                                    USART_Tx2[k++] = 0x5A;
                                                    USART_Tx2[k++] = 0X09;
                                                    USART_Tx2[k++] = 0X82;
                                                    USART_Tx2[k++] = 0X00;
                                                    USART_Tx2[k++] = 0X00 + i*7;
                                                    TreePoint_To_ASCII(Temp[i+1], lptr);
                                                    for(z=0 ; z<6 ;z++)
                                                    {  
                                                        if(arr[z] == '\0')
                                                        {
                                                            break;
                                                        }
                                                        else
                                                        {
                                                            USART_Tx2[k++]= arr[z];
                                                        }
                                                    }
                                                }
                                                //********曲线*******************//
                                                USART_Tx2[k++] = 0xA5;
                                                USART_Tx2[k++] = 0x5A;
                                                USART_Tx2[k++] = 0X12;
                                                USART_Tx2[k++] = 0X84;//画图
                                                USART_Tx2[k++] = 0xFF;
                                                for(i = 0; i < 8; ++i)//数据取两位小数有效值，扩大100倍，然后取整数
                                                {
                                                    Line_Data = (u16)(Temp[Display_Channel[i+1]] * 100);
                                                    USART_Tx2[k++] = Line_Data >> 8;
                                                    USART_Tx2[k++] = Line_Data;
                                                }        
                                                Line_Flag = 0X0000;
                                                for(i = 1; i < 9; ++i)
                                                {//8路图标显示
                                                    if(Display_Channel[i])
                                                    {
                                                        USART_Tx2[k++] = 0xA5;
                                                        USART_Tx2[k++] = 0x5A;
                                                        USART_Tx2[k++] = 0X05;
                                                        USART_Tx2[k++] = 0X82;
                                                        USART_Tx2[k++] = 0X01;
                                                        USART_Tx2[k++] = Display_Channel[i]-1;
                                                        USART_Tx2[k++] = 0X00;
                                                        USART_Tx2[k++] = i;
                                                    }
                                                    switch(Display_Channel[i])
                                                    {//找出位显示曲线的通道
                                                        case 1:   Line_Flag |=0X0001;
                                                        break;
                                                        case 2:   Line_Flag |=0X0002;
                                                        break;
                                                        case 3:   Line_Flag |=0X0004;
                                                        break;
                                                        case 4:   Line_Flag |=0X0008;
                                                        break;
                                                        case 5:   Line_Flag |=0X0010;
                                                        break;
                                                        case 6:   Line_Flag |=0X0020;
                                                        break;
                                                        case 7:   Line_Flag |=0X0040;
                                                        break;
                                                        case 8:   Line_Flag |=0X0080;
                                                        break;
                                                        case 9:   Line_Flag |=0X0100;
                                                        break;
                                                        case 10:  Line_Flag |=0X0200;
                                                        break;
                                                        case 11:  Line_Flag |=0X0400;
                                                        break;
                                                        case 12:  Line_Flag |=0X0800;
                                                        break;
                                                        case 13:  Line_Flag |=0X1000;
                                                        break;
                                                        case 14:  Line_Flag |=0X2000;
                                                        break;
                                                        case 15:  Line_Flag |=0X4000;
                                                        break;
                                                        case 16:  Line_Flag |=0X8000;
                                                        break;
                                                        default:
                                                        break;
                                                    }
                                                }
                                                for(i = 1; i < 17; ++i)
                                                {//未显示曲线的通道图标0 显示
                                                    if((Line_Flag&0x01)==0)
                                                    {
                                                        USART_Tx2[k++] = 0xA5;
                                                        USART_Tx2[k++] = 0x5A;
                                                        USART_Tx2[k++] = 0X05;
                                                        USART_Tx2[k++] = 0X82;
                                                        USART_Tx2[k++] = 0X01;
                                                        USART_Tx2[k++] = i-1;
                                                        USART_Tx2[k++] = 0X00;
                                                        USART_Tx2[k++] = 0x00;
                                                    }
                                                    Line_Flag >>= 1;
                                                }
              break;
			  
			  
              case   Set_Display:
                                                USART_Tx2[k++] = 0xA5;
                                                USART_Tx2[k++] = 0x5A;
                                                USART_Tx2[k++] = 0X0A;
                                                USART_Tx2[k++] = 0X82;
                                                USART_Tx2[k++] = 0X03;
                                                USART_Tx2[k++] = 0X20 ;
                                                TreePoint_To_ASCII(Temp[Set_ChX], lptr);
                                                for(z=0 ; z<7 ;z++)
                                                {  
                                                    if(arr[z] == '\0')
                                                    {
                                                        break;
                                                    }
                                                    else
                                                    {
                                                        USART_Tx2[k++]= arr[z];
                                                    }
                                                }
                                                if(Calib_Mode == Res_Mode)
                                                {//图标显示
                                                    USART_Tx2[k++] = 0xA5;
                                                    USART_Tx2[k++] = 0x5A;
                                                    USART_Tx2[k++] = 0X05;
                                                    USART_Tx2[k++] = 0X82;
                                                    USART_Tx2[k++] = 0X03;
                                                    USART_Tx2[k++] = 0x40;
                                                    USART_Tx2[k++] = 0X00;
                                                    USART_Tx2[k++] = 0x01;
                                                    
                                                    USART_Tx2[k++] = 0xA5;
                                                    USART_Tx2[k++] = 0x5A;
                                                    USART_Tx2[k++] = 0X05;
                                                    USART_Tx2[k++] = 0X82;
                                                    USART_Tx2[k++] = 0X03;
                                                    USART_Tx2[k++] = 0X41;
                                                    USART_Tx2[k++] = 0X00;
                                                    USART_Tx2[k++] = 0x02;
                                                }
                                                else
                                                {
                                                    USART_Tx2[k++] = 0xA5;
                                                    USART_Tx2[k++] = 0x5A;
                                                    USART_Tx2[k++] = 0X05;
                                                    USART_Tx2[k++] = 0X82;
                                                    USART_Tx2[k++] = 0X03;
                                                    USART_Tx2[k++] = 0x40;
                                                    USART_Tx2[k++] = 0X00;
                                                    USART_Tx2[k++] = 0x00;
                                                    
                                                    USART_Tx2[k++] = 0xA5;
                                                    USART_Tx2[k++] = 0x5A;
                                                    USART_Tx2[k++] = 0X05;
                                                    USART_Tx2[k++] = 0X82;
                                                    USART_Tx2[k++] = 0X03;
                                                    USART_Tx2[k++] = 0X41;
                                                    USART_Tx2[k++] = 0X00;
                                                    USART_Tx2[k++] = 0x03;
                                                }
              
              break;

			  
              default:
              break;
          }
    USART1_Tx(k);
}

//补偿
u16 Corr_K_B(u8 Channel,u16 AD_Temp)
{
    u16 Data_Y = 0;
    if(Channel<8)
    {
        Data_Y = (u16)(Corr_K1 * AD_Temp + Corr_B1);
    }
    else
    {
        Data_Y = (u16)(Corr_K2 * AD_Temp + Corr_B2);
    }
    return Data_Y;
}
//**********************************************************************************************//
//PC串口命令

//校验命令: 起始符	  命令	 通道  长度  数据	   校验  结束符
//示例: 	   $	 JZ/JT	  15	6	115.27	     A 	    ； 

//校验命令: 起始符	命令	输出频率	滤波窗口	输出制式	输出通道	校验	结束符
//示例: 	  $ 	 CJ 	  10		    9		   0		   FF		  A 	   ；

//**********************************************************************************************//
void New_Order(void)
{
    u8 CS = 0;   
    u16 i;
    u8 CHANNLE_X = 0;
    u16 Tem = 0;
    float Bit_R;
    float Tem_R;
    for(i= 0 ;i<RxTim3-1;i++)  //总共接收了RxTim3个byte数据
    {
        CS += RxBuffer_3[i];   //CS进行求和
    }
    CS = 0X100 - CS;           //?   数据校验
    
    if(RxBuffer_3[RxTim3 - 2] =='*')//奇偶校验成功 *为临时调试用
    { 
        
        if(RxBuffer_3[1] == 'J')//解析校验命令*********************************//
        {
            Length_Order = (RxBuffer_3[5] - 48) * 10;//先解析校验数据内容长度 十位,将ASCII码转化为十进制数据
            Length_Order += RxBuffer_3[6] - 48;      //Length_Order = Length_Order + (RxBuffer_3[6] - 48);
            //************************************************************//

			//通道计算
            CHANNLE_X = (RxBuffer_3[3] - 48)*10;
            CHANNLE_X += RxBuffer_3[4] - 48;

			
            //************************************************************//
            Col_DATA = 0;
			
			//Z:标准电阻校验   T：温度校验
            if(RxBuffer_3[2] == 'Z')
            {
				//Z:标准电阻校验
                Cal_Mode = 1;

                for(i = 0; i < Length_Order; ++i)     //124.56
                {
                    Col_DATA *= 10;                       
                    Col_DATA += RxBuffer_3[7 + i] - 48;
                }
               // Col_DATA 实际值应为除以100后的值 
            }
            else if(RxBuffer_3[2] == 'T')
            {
				
				/*
					以124.56为例,124.56*100 = 12456，所以在串口输入的数据应该为: 12456
					(1) i=0; RxBuffer_3[7]  = '1'; Col_DATA = 0*10 + '1'-48    = 1
					(1) i=1; RxBuffer_3[8]  = '2'; Col_DATA = 1*10 + '2'-48    = 12						
					(1) i=2; RxBuffer_3[9]  = '4'; Col_DATA = 12*10 + '4'-48   = 124
					(1) i=3; RxBuffer_3[10] = '5'; Col_DATA = 124*10 + '5'-48  = 1245
					(1) i=4; RxBuffer_3[11] = '6'; Col_DATA = 1245*10 + '6'-48 = 12456

				*/
				
				//T：温度校验   温度值放大100倍
                Cal_Mode = 2;
                for(i = 0; i < Length_Order; ++i)
                {
                    Col_DATA *= 10; 
                    Col_DATA += RxBuffer_3[7 + i] - 48; 
                }
            }
            else
            {
                Cal_Mode = 0;
            }
            //开始校验程序*************************************************//
            switch(Cal_Mode)
            {
                case 0:
                          break;

				/*
					CHANNLE_X = 8; ADC_Value[CHANNLE_X] = ADC_Value[8] = 32976;
					
					Tem = 5001*(65535-32976)/32976;



8 5003



				*/
						  
                case 1:  //阻值校验
                                Tem = 65535 - ADC_Value[CHANNLE_X];
                                Tem = Col_DATA* Tem / ADC_Value[CHANNLE_X];
                                if((Tem <11000)&&(Tem > 9000))
                                {
                                     REF_R.u16_D[CHANNLE_X] = Tem;
                                     sEE_WriteBuffer(REF_R.u8_D, 0x02, 2*(CHANNLE_X+1)); 
                                     sEE_WaitEepromStandbyState();    
                                }
                                
                          break;
						  
                case 2:  //温度校验
                                Tem = Col_DATA*10 -320;//找到元素在数组中的位置
                                Bit_R = Col_DATA%10;
                                Bit_R /= 10;
                                Bit_R = Bit_R* (RT[Tem] - RT[Tem + 1]);
                                Tem_R = RT[Tem] + Bit_R;
                                Tem = 65535 - ADC_Value[CHANNLE_X];
                                Tem = (u16)(Tem_R* Tem / ADC_Value[CHANNLE_X]); 
								if((Tem<11000)&&(Tem > 9000))
                                {
                                     REF_R.u16_D[CHANNLE_X] = Tem;
                                     sEE_WriteBuffer(REF_R.u8_D, 0x02, 2*(CHANNLE_X+1)); 
                                     sEE_WaitEepromStandbyState();    
                                }
                           break;
                default:
                           break;
            }   
        }

		
        else if(RxBuffer_3[1] == 'C')//采集设定命令************************//
        {

			
            Rate_Out = (RxBuffer_3[3] - 48)*10;//串口输出速率调整，最大50Hz 25 18 12 10 8 7 6 5 4 3 2 1
                                               //                        2   3  4  5 6 7 8 910 12 25 50          
            Rate_Out += (RxBuffer_3[4] - 48);
            if(Rate_Out > 50)
            {
                Rate_Out = 50;
            }
            Col_Times = 50 / Rate_Out*2;
            if(Col_Times <= 1)
            {
                Col_Times = 0;
            }

			
            //设置滤波窗口大小**********************************************//
            Mid_Filt_Win = RxBuffer_3[5] - 48;
            if((Mid_Filt_Win % 2)== 0)//滤波窗口设置为偶数 自动加一变奇数
            {
                Mid_Filt_Win ++;
            }

			
            //输出制式*****************************************************//
             Out_Flag = RxBuffer_3[6] - 48;

			
            //设置采样窗口*************************************************//
            //举例: 'F'                         'F'
            if((RxBuffer_3[7] > 70)||(RxBuffer_3[8]>70))
            {
                RxBuffer_3[7] = 70;
                RxBuffer_3[8] = 70;
            }
            Col_Channel = 0;
			// 'F' - 55 = 70 - 55 = 15 = 0XF
            Col_Channel = RxBuffer_3[7] - 55;  //ASCII码表中，‘7’= 55
            Col_Channel *= 16; //0XF * 16 = 0XF0
            Col_Channel += RxBuffer_3[8] - 55; //OXF0 + 0X0F = 0XFF
        }
    }
    else
    {
        //奇偶校验失败   
    }
    RxTim3 = 0;
}


/***************************************************************************************************************/
/******************************************** 触摸屏命令********************************************************/
/***************************************************************************************************************/

/*

MCU读取串口屏的指令格式：(即MCU向串口屏发送数据，通过USART1_Tx();该函数来实现，DMA功能传送数据)
5A A5 04 83 0000 01 	
5A A5  表示：帧头			 
04	   表示：数据长度			 
83	   表示：读数据存储区指令			 
0000   表示：变量地址（两个字节）			 
01	   表示：从 0000 地址开始读 1 个字长度数据				

读完以后屏会向串口返回读应答：(即通过USART1的串口中断函数来从串口屏接收数据，存储在数组RxBuffer_2[]中，在本函数中进行解析)			
5A A5 06 83 0000 01 0002			
5A A5   表示：帧头		                            RxBuffer_2[0]   RxBuffer_2[1]		
06      表示：数据长度  	                        RxBuffer_2[2]			
83      表示：读变量存储器指令指令                  RxBuffer_2[3]				
0000    表示：变量地址（两个字节）	                RxBuffer_2[4]	RxBuffer_2[5]		
01      表示：从 0000 地址开始读 1 个字长度数据		RxBuffer_2[6]	
0002    表示：0000 地址里的数据值是 2	            RxBuffer_2[7]   RxBuffer_2[8]		

*/
void New_Comm(void)
{
    u16 ADDR = 0;
    u16 Data = 0;
    u8     i = 0;
    u8 k = 0;
    u8 Exi_Flag = 0;
    u16 Tem_1,Tem_2;
    u8 Tem[20] = {0};
    u8 Point = 0;
    u8 End = 0;
    u32 Temp_1 = 0;
//    float Bit_R,Tem_R;
    if(RxBuffer_2[3] == 0X83)
    {
		//计算变量地址，即选择不同的内存块
        ADDR  = RxBuffer_2[4];
        ADDR <<= 8;
        ADDR += RxBuffer_2[5];


		//对应变量地址下的数据值，即对应内存块下面的存储的数据值
        Data  = RxBuffer_2[7];
        Data <<= 8;
        Data += RxBuffer_2[8];
        
        switch(ADDR)
        {
			//ASCII码表中:'0'-->0X30/48; '.'-->0X2E/46;'A'-->0X41/65
            case 0X0300:                  //校准通道选择
                                          Tem_1 = RxBuffer_2[7] - 48;
                                          Tem_2 = RxBuffer_2[8] - 48;
                                          if((Tem_1 <10)&&(Tem_2 <10))
                                          {
                                              Set_ChX = Tem_1*10 + Tem_2;
                                          }
                                           break;
            case 0X0310:               //校准值输入
										/*****************************************************************************************
										  举例：例如输入150.886
										  则：	Tem[7]  = RxBuffer_2[7] - 48  = '1' - 48 = 1
												Tem[8]  = RxBuffer_2[8] - 48  = '5' - 48 = 5
												Tem[9]  = RxBuffer_2[9] - 48  = '0' - 48 = 0
												Tem[10] = RxBuffer_2[10] - 48 = '.' - 48 = 0; Tem[10] = 0; point = 10;
												Tem[11] = RxBuffer_2[11] - 48 = '8' - 48 = 8
												Tem[12] = RxBuffer_2[12] - 48 = '8' - 48 = 8
												Tem[13] = RxBuffer_2[13] - 48 = '6' - 48 = 6; 
												RxBuffer_2[14] = 0xff;                        End = 14;
										*****************************************************************************************/
                                          for( i = 7; i < 15; ++i)
                                          {
                                              Tem[i] = RxBuffer_2[i] - 48;
                                              if(RxBuffer_2[i] == 0X2E)//小数点
                                              {
                                                  Point = i;
                                                  Tem[i] = 0;
                                              }
                                              else if(RxBuffer_2[i] ==0xFF)
                                              {
                                                  End = i;
                                                  break;   
                                              }
                                              
                                          }
										  /**********************************************************************************
										  举个栗子：仍然是上述栗子
										  经过上述for循环以后：150.886-->1500886，End = 14;
										  i = 7; Col_DATA = 0*10 = 0；  Col_DATA = 0+   Tem[7] = 1;
										  i = 8; Col_DATA = 1*10 = 10； Col_DATA = 10 + Tem[8] = 15;
										  i = 9; Col_DATA = 15*10 = 150； Col_DATA = 150 + Tem[9] = 150;
										  i = 10; Col_DATA = 150*1 = 150； Col_DATA = 1500 + Tem[10] = 150;
										  i = 11; Col_DATA = 150*10 = 1500； Col_DATA = 1500 + Tem[11] = 1508;
										  i = 12; Col_DATA = 1508*10 = 15080； Col_DATA = 15080 + Tem[12] = 15088;
										  i = 13; Col_DATA = 15088*10 = 150880； Col_DATA = 150880 + Tem[13] = 150886;
								
										  **********************************************************************************/
                                          Col_DATA = 0;
                                          for( i = 7; i < End; ++i)
                                          {
											  if (Point == i)
											  {
												Col_DATA *= 1;
												Col_DATA += Tem[i]; 
											  }
											  else
											  {
												Col_DATA *= 10;
												Col_DATA += Tem[i];  
											  }
                                              
                                          } 
										  
										  /**********************************************
										  Col_Temp = Col_DATA = 150886;
										  
										  
										  ************************************/
                                          Col_Temp = Col_DATA;
//                                          if(Point)
//                                          {
//                                              while(Point>0)
//                                              {
//                                                  Point --;
//                                                  Col_Temp /=10;
//                                              }
//                                          }
            break;
            case 0X0330:               //校准方式选择
                                        if(Data == 0x01)
                                        {
                                            Calib_Mode = Res_Mode;
                                        }
                                        else if(Data == 0x02)
                                        {
                                            Calib_Mode = Temp_Mode;
                                        }
                                        else if(Data == 0x03)
                                        {
                                            switch(Calib_Mode)
                                            {
                                                case 0:
                                                break;
                                                case 1:  //阻值校验
                                                              Temp_1 = 65535 - ADC_Value[Set_ChX-1];
                                                              Temp_1 = Col_DATA* Temp_1 / ADC_Value[Set_ChX-1];//计算内部阻值
                                                              if((Temp_1 <11000)&&(Temp_1 > 9000))
                                                              {
                                                                  REF_R.u16_D[Set_ChX-1] = Temp_1;
                                                                  sEE_WriteBuffer(REF_R.u8_D, 0x02, 2*(Set_ChX-1)); 
                                                                  sEE_WaitEepromStandbyState();    
                                                              }
                                                
                                                break;
                                                case 2:  //温度校验温度范围在[29.800, 105.200]范围内的时候，进行校准
														 //NOTE:ch1-ch7代表的是计量单位对各校准点105.00, 95.00, 90.00, 70.00, 60.00, 50.00, 30.00的校准数据
														 //NOTE:ch9-ch15代表的是我们工装对各校准点105.00, 95.00, 90.00, 70.00, 60.00, 50.00, 30.00的对应数据
                                                              if((Col_Temp<(105000 + 200)) && (Col_Temp > (30000 - 200)))
                                                              {
																  if (((u8)((Set_ChX - 1) / 8) == 0))
																  {
																	  COR_T.u32_D[Set_ChX-1] = Col_Temp;
																	  sEE_WriteBuffer(COR_T.u8_D[4*(Set_ChX-1)], 0x02+32+4*(Set_ChX-1), 4); 
																	  sEE_WaitEepromStandbyState();   
																  }
																  else 
																  {
																	  GOZ_T.u32_D[Set_ChX-1] = Col_Temp;
																	  sEE_WriteBuffer(GOZ_T.u8_D[4*(Set_ChX-1)], 0x02+32+4*(Set_ChX-1), 4); 
																	  sEE_WaitEepromStandbyState();     
																  }
                                                                   
                                                              }
                                                break;
                                                default:
                                                break;
                                            }   
                                        }
            break;
            case 0X0400:               //切换屏幕界面
                                        switch(Data)
                                        {
                                            case 0x0001 :            LCD_Interface = Line_Display;
                                            break;
                                            case 0x0004 :            LCD_Interface = Main_Display;
                                            break;
                                            case 0x0002 :            LCD_Interface = Data_Display;
                                            break;
                                            case 0x0005 :            LCD_Interface = Main_Display;
                                            break;
                                            case 0x0003 :            LCD_Interface = Set_Display;
                                                                     k = 0;
                                                                     USART_Tx2[k++] = 0xA5;
                                                                     USART_Tx2[k++] = 0x5A;
                                                                     USART_Tx2[k++] = 0X05;
                                                                     USART_Tx2[k++] = 0X82;
                                                                     USART_Tx2[k++] = 0X03;
                                                                     USART_Tx2[k++] = 0X00 ;
                                                                     USART_Tx2[k++] = 0X5F ;
                                                                     USART_Tx2[k++] = 0X5F ;
                                                                     
                                                                     USART_Tx2[k++] = 0xA5;
                                                                     USART_Tx2[k++] = 0x5A;
                                                                     USART_Tx2[k++] = 0X08;
                                                                     USART_Tx2[k++] = 0X82;
                                                                     USART_Tx2[k++] = 0X03;
                                                                     USART_Tx2[k++] = 0X10 ;
                                                                     USART_Tx2[k++] = 0X5F ;
                                                                     USART_Tx2[k++] = 0X5F ;
                                                                     USART_Tx2[k++] = 0X5F ;
                                                                     USART_Tx2[k++] = 0X5F ;
                                                                     USART_Tx2[k++] = 0X5F ;
                                                                     USART1_Tx(k);
                                            break;
                                            case 0x0006 :            LCD_Interface = Main_Display;
                                            break;
                                            default:
                                            break;
                                        }
            break;
            case 0X0200:               //显示曲线的通道设置
                                        for(i = 1; i < 9; ++i)
                                        {
                                            if(Display_Channel[i] == Data)
                                            {
                                                Display_Channel[i] = 0;
                                                Exi_Flag = 1;
                                            }
                                        }
                                        if(Exi_Flag == 0)
                                        {
                                            for(i = 1; i < 9; ++i)
                                            {
                                                if(Display_Channel[i] == 0)
                                                {
                                                    Display_Channel[i] = Data;
                                                    break;
                                                }
                                            }  
                                        }
            break;
            case 0X0120: //y轴下降
                              Y_Axle -= 100;
                              if(Y_Axle < 3000)
                              {
                                  Y_Axle = 3000;  
                              }          
                              k = 0;
//                              USART_Tx2[k++] = 0xA5;
//                              USART_Tx2[k++] = 0x5A;
//                              USART_Tx2[k++] = 0X05;
//                              USART_Tx2[k++] = 0X82;
//                              USART_Tx2[k++] = 0X01;
//                              USART_Tx2[k++] = i+1;
//                              USART_Tx2[k++] = 0X00;
//                              USART_Tx2[k++] = 0x00;
//                              USART2_Tx(k);
//                              USART2_BUSY = 1;
            break;
            case 0X0121://y轴上升
                              Y_Axle += 100;
                              if(Y_Axle > 15000)
                              {
                                Y_Axle = 15000;  
                              }
            break;
            case 0X0122://x轴拉长
                              X_Axle -= 2;
                              if((X_Axle<= 1)||(X_Axle>=100))
                              {
                                  X_Axle = 1;
                              }
            break;
            case 0X0123://x轴缩短
                              X_Axle += 2;
                              if(X_Axle> 51)
                              {
                                  X_Axle = 51;
                              }
            break;
            case 0X0124://清屏
            
                              USART_Tx2[0] = 0xA5;
                              USART_Tx2[1] = 0x5A;
                              USART_Tx2[2] = 0X03;
                              USART_Tx2[3] = 0X80;
                              USART_Tx2[4] = 0XEB;
                              USART_Tx2[5] = 0X55;   
                              USART1_Tx(6);
            break;
            default :
            break;
        }
    }
    RxBuffer_2[0] = 0;
    RxBuffer_2[1] = 0;
    RxBuffer_2[2] = 0;
    RxTim2 = 0;
    Usart2_FLAG = 0;
       
}


/**********************************************************************************************************/
/********************************** 计算实际温度函数 ******************************************************/
/********************************** 测试电阻AD值 上拉电阻 参考电压 ****************************************/
/**********************************************************************************************************/
float Calculate_Temp_SZ(u16 AD_Res , float UP_Res , float V_ref )
{
    float Res   = 0;
    float V_Res = 0;
    float T = 0;
    u16   X = 0;
    u16   i = 0;
	
    V_Res = AD_Res*V_ref/65535;//计算电阻分压
    
    if(V_Res<2)
    {
        Res   = V_Res*UP_Res/(V_ref - V_Res);//计算电阻


		//温度范围检查
        if(Res > 36668.6695) //32度以下无表可查
        {
					T = Calculate_Temp_Less_32(Res);
					//T = (60.12837 - 7.72368E-4*Res )*10;
        }
        else if(Res < 731.15)//149以上无表可查
        {
            T = 1500;
        }

		
        else
        {
            //32-149℃ 共1180个元素，为快速查询从第590个为分界两边查
            //if Res = 35494.202,  RT[6] = 35594.202,RT[7] = 35433.3275, //此时i = 584
            if(Res >= RT[590])
            {
                while(Res >= RT[590-i])
                {
                    i++;
                } 
                X = 590 - i ;  // X = 590 - 584 = 6  35594.202, 35433.3275,
                //T = 320 + 6 + (RT[6] - Res) / (RT[6]-RT[7]) = 326 + (35594.202 - 35494.202) / (35594.202 - 35433.3275);
                // T = 326 + 1/160.8745 = 326.006 
                //每个数值之间差0.1℃，此处将温度值放大了10倍，第一个值对应的温度是32℃
                //(δX / δY) * δY = δX,此处δY = 0.1℃，扩大了10倍，所以0.1℃就变成了1℃，故此处的δX = (δX / δY) * δY = δX / δY
                T = 320+ X +(RT[X] - Res) / (RT[X]-RT[X+1]);
            }
            else
            {
                while(Res < RT[590+i])
                {
                    i++;
                }
                X = 590 + i; 
                T = 320+ X +(RT[X] - Res) / (RT[X]-RT[X+1]);
            }
        }
    }
    else
    {
     T = 0x00;   
    }
	
	T = Temp_Correction(T/10);
	
    return T;
}



//当温度<32℃时候，需要通过另外一个表格进行查询
float Calculate_Temp_Less_32(float ResVal)
{
	float T = 0;
    u16   X = 0;
    u16   i = 0;
	
	if(ResVal >= RT_32[17])
	{
			while(ResVal >= RT_32[16-i])
			{
					i++;
			} 
			X = 16 - i ;  
			T = 0+ X*10 +((RT_32[X] - ResVal) / (RT_32[X]-RT_32[X+1]))*10;
	}
	else
	{
			while(ResVal < RT_32[16+i])
			{
					i++;
			}
			X = 16 + i; 
			T = 0+ X*10 +((RT_32[X] - ResVal) / (RT_32[X]-RT_32[X+1]))*10;
	}	
	return T;
}


/*
函数功能：实现对整个系统的温度校准
输入参数：float temprature,输入需要校准的温度值
输出参数：校准后的温度值
NOTE:此处采用点斜式计算y = k*x + b；线性方程
*/
float Temp_Correction(float temprature)
{
	u16 X = 0;
	u16 i = 0;
	float T = 0;
	float k = 0;
	
	//如果是在《聚合酶链反应分析仪校准规范》规定的温度之外，则不进行校准，原来是多少就是多少
	if ((temprature < 30.00) || (temprature > 105.00))
	{
		return temprature;
	}

	//在《聚合酶链反应分析仪校准规范》规定的温度之外，则进行分段校准
	if(temprature >= Temp_Compare[3])
	{
		/*
		举例1：temprature = 93；则 93 > 70; i = 1; 93>90; i =2; 93<95; 最终i = 2； X = 3-2 = 1;
		举例2：temprature = 98；则 98 > 70; i = 1; 98>90; i =2; 98<95; i=3； 95<105; X = 3-3 = 0
		*/
		while(temprature >= Temp_Compare[3-i])
		{
			i++;
		} 
		X = 3 - i ;  
		//求斜率
		k = ((float)COR_T.u32_D[X+1] - (float)COR_T.u32_D[X]) / ((float)GOZ_T.u32_D[X+1] - (float)GOZ_T.u32_D[X]);
		//利用点斜式实现线性插值
		//注意此处写入的温度扩大了1000倍，所以求实际温度的时候需要缩小1000倍
		T = (float)COR_T.u32_D[X] + k*(temprature*1000 - (float)(GOZ_T.u32_D[X]));  
	}
	else
	{
		/*
		举例1：temprature = 55；则 55 < 70; i = 1; 55<60; i =2; 55>50; 最终i = 2； X = 3+2 = 5;
		举例2：temprature = 36；则36 < 70; i = 1; 36<60; i =2; 36<50; i=3； 36>30;  最终i =3; X = 3+3 = 6
		*/
		while(temprature < Temp_Compare[3+i])
		{
			i++;
		}
		X = 3 + i; 
		k = ((float)COR_T.u32_D[X] - (float)COR_T.u32_D[X-1]) / ((float)GOZ_T.u32_D[X] - (float)GOZ_T.u32_D[X-1]);
		//注意此处写入的温度扩大了1000倍，所以求实际温度的时候需要缩小1000倍
		T = (float)COR_T.u32_D[X-1] + k*(temprature*1000 - (float)(GOZ_T.u32_D[X-1])); 
	}	
	return (T/1000);	
}

/*************************************************************************************************************
NOTE:上面的函数采用点斜式实现分段线性插值
	(1)temprature >= Temp_Comp[3]
	(x0, y0)-->( GOZ_T.u32_D[X], COR_T.u32_D[X])
	(x1, y1)-->(GOZ_T.u32_D[X+1], COR_T.u32_D[X+1])
	k = (y1-y0)/(x1-x0) = (COR_T.u32_D[X+1] - COR_T.u32_D[X]) / (GOZ_T.u32_D[X+1] - GOZ_T.u32_D[X]);
	y = y0 + k(x -x0)   =  COR_T.u32_D[X] + k*(temprature - GOZ_T.u32_D[X]);               
	==> y = y0 + (y1-y0)*(x-x0)/(x1-x0);
	
	(2)temprature < Temp_Comp[3]
	(x0, y0)-->( GOZ_T.u32_D[X-1], COR_T.u32_D[X-1])
	(x1, y1)-->(GOZ_T.u32_D[X], COR_T.u32_D[X])
	k = (y1-y0)/(x1-x0) = (COR_T.u32_D[X] - COR_T.u32_D[X-1]) / (GOZ_T.u32_D[X] - GOZ_T.u32_D[X-1]);
	y = y0 + k(x -x0)   =  COR_T.u32_D[X-1] + k*(temprature - GOZ_T.u32_D[X-1]);               
	==> y = y0 + (y1-y0)*(x-x0)/(x1-x0);	
*****************************************************************************************************************/



//中值滤波
u16 Mid_Data_Filter(u16 CHx_Value , u16 Mid_Num , u8 Chx)//Mid_Data_Num 为奇数
{
   u16 temp;
   u8 i,j;
   /***************************************************************************************************************************************
	(1)当Chx = 0；
	   第一次进来的时候: Mid_Num= 9； Mid_data_buf[0][0] = 当前采样值；Mid_count[0] = 1;
	   第二次进来的时候: Mid_Num= 9； Mid_data_buf[0][1] = 当前采样值；Mid_count[0] = 2;
	   第三次进来的时候: Mid_Num= 9； Mid_data_buf[0][2] = 当前采样值；Mid_count[0] = 3;
	   ......
	   第九次进来的时候: Mid_Num= 9； Mid_data_buf[0][8] = 当前采样值；Mid_count[0] = 9;此时:Mid_count[0]=9;故将Mid_count[0]清零
	   第十次进来的时候: Mid_Num= 9； Mid_data_buf[0][0] = 当前采样值；Mid_count[0] = 1;对Mid_data_buf[0][0]的值进行更新，然后进行冒泡排序
	(2)当Chx = 1；
	   第一次进来的时候: Mid_Num= 9； Mid_data_buf[1][0] = 当前采样值；Mid_count[1] = 1;
	   第二次进来的时候: Mid_Num= 9； Mid_data_buf[1][1] = 当前采样值；Mid_count[1] = 2;
	   第三次进来的时候: Mid_Num= 9； Mid_data_buf[1][2] = 当前采样值；Mid_count[1] = 3;
	   ......
	   第九次进来的时候: Mid_Num= 9； Mid_data_buf[1][8] = 当前采样值；Mid_count[1] = 9;此时:Mid_count[1]=9;故将Mid_count[0]清零
	   第十次进来的时候: Mid_Num= 9； Mid_data_buf[1][0] = 当前采样值；Mid_count[1] = 1;对Mid_data_buf[1][0]的值进行更新，然后进行冒泡排序

   NOTE1:Mid_data_buf[][]该二维数组用来存储不同通道的采样值，Mid_data_buf[0][0]~Mid_data_buf[0][8]用来存放通道0的9次采样值
                                                            Mid_data_buf[1][0]~Mid_data_buf[1][8]用来存放通道1的9次采样值
  													        Mid_data_buf[2][0]~Mid_data_buf[2][8]用来存放通道2的9次采样值
  													        ......
   															Mid_data_buf[15][0]~Mid_data_buf[15][8]用来存放通道15的9次采样值
   															
   NOTE2:Mid_count[]用来计数每个通道的进入滤波的次数；Mid_count[0]记录0通道，Mid_count[0]的取值范围是0-9，等于9以后自动清零
													  Mid_count[1]记录1通道，Mid_count[1]的取值范围是0-9，等于9以后自动清零
													  Mid_count[2]记录2通道，Mid_count[2]的取值范围是0-9，等于9以后自动清零
													  Mid_count[3]记录3通道，Mid_count[3]的取值范围是0-9，等于9以后自动清零
													  ......
													  Mid_count[15]记录15通道，Mid_count[15]的取值范围是0-9，等于9以后自动清零

   ******************************************************************************************************************************************/
   Mid_data_buf[Chx][Mid_count[Chx]++] = CHx_Value; 
   
   if(Mid_count[Chx] >= Mid_Num)Mid_count[Chx] = 0;

   //对采集到的数据进行冒泡排序
   for (j=0;j<Mid_Num-1;j++)
   {
      for (i=0;i<Mid_Num-j-1;i++)
      {
         if ( Mid_data_buf[Chx][i]>Mid_data_buf[Chx][i+1] )
         {
            temp = Mid_data_buf[Chx][i];
            Mid_data_buf[Chx][i] = Mid_data_buf[Chx][i+1];
            Mid_data_buf[Chx][i+1] = temp;
         }
      }
   }
   return Mid_data_buf[Chx][(Mid_Num-1)/2];
}
////滑动平均滤波
//u16 Average_Average_Data(u16 Current_CHx_Value ,u8 Chx)
//{
//    u8 i;
//    u16 Av_temp;
//    u32 Average_Sum = 0;
//    Average_Data[Chx][Average_Count[Chx]] = Current_CHx_Value;
//    for(i=0;i<5;i++)
//    {
//       Average_Sum = Average_Sum + Average_Data[Chx][i];
//    }
//    Av_temp = (u16)(Average_Sum/5);
//    Average_Count[Chx]++;
//    if(Average_Count[Chx] >= 5)
//    {
//       Average_Count[Chx] = 0;
//    }
//    return Av_temp;
//}
//

#ifdef  USE_FULL_ASSERT
void assert_failed(uint8_t* file, uint32_t line)
{ 
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */

  /* Infinite loop */
  while (1)
  {
  }
}
#endif
/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/



